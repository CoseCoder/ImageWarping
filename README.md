# imageWarping
IDW and RBF
# 一、问题描述
从输入输出的角度来看，图像变形问题可视为以下形式的问题 
输入： 给定 n 对样本点(p_i,q_i), p_i,q_iR^2, i1,…,n
输出： 一个至少连续的函数f:R^2R^2满足f(p_i )=q_i, i1,…,n
# 二、算法描述（复杂度、实现过程）
## 2.1	IDW方法
IDW 插值法是由 Shepard 所提出的，该方法要求找到满足以下形式的函数：
f(p)=∑_(i=1)^n▒〖w_i (p) f_i (p) 〗
(1) f_i (x)满足f(p_i )=q_i，是对于点p_i的局部近似i1,…,n。对于局部近似f_i，一般使用线性或二次多项式，多项式系数可以由数据点处的导数值来确定。
(2) w_i:R^2 R是权函数，须满足条件w_i (p_i )=1, ∑_(i=1)^n▒〖w_i (p)=1〗并且w_i (p)≥0,i1,…,n。
Shepard提出了以下简单的权函数：
w_i (p)=(σ_i (p))/(∑_(j=1)^n▒〖σ_j (p) 〗)其中σ_j (p)=1/(ⅆ(p-p_j )^u )	 ⅆ(p-p_j)是p与p_j的距离
算法中f_i (p)=q_i+D_i (p-p_i )，考虑误差函数：
E_i (D)=∑_(j=1,j!=i)^n▒〖w_i (p_j ) ‖q_i+(■(d_11&d_12@d_21&d_22 ))(p_j-p_i )-q_j ‖^2 〗
通过对矩阵求偏导可以得到(其余3个变量同理): 
 
矩阵的二阶偏导数表明，一阶导数的零点确实是最小值。从而得到了四个未知数为四个方程组的线性方程组。如果行列式不等于零，则该系统具有唯一解。
行列式的值为:
 
若deti=0,则有唯一解:
   
若deti≠0,变换矩阵D可采用以下式子计算:
 
	若不计算变换矩阵D,也可以将Di设置成相同的矩阵(例如2阶单位矩阵)

时间复杂度:	IDW插值法是一种全局插值法，即全部样本点都参与某一待估点的估算之中，所以它的计算复杂度为O(nN)，其中n为样本点个数，而N为需要变换的像素点的数量。

	本次所用程序使用的局部近似函数的Di采用两种方式计算(均采用u=2):
	将Di设置成2阶单位矩阵,局部近似函数为f_i (p)=q_i+(p-p_i )
	采用上文显示的计算公式计算Di(分为deti=0与deti≠0两种情况)
## 2.2	RBF方法
RBF 方法已经被验证，在离散数据的多元插值问题上是一个很有效的工具。该方法要求我们找到满足以下形式的插值函数：
f(x)=∑_(i=1)^n▒〖_i R(ⅆ_i (x))+P_m (x)〗
_iR^2是系数向量，可以通过将数据点放入上式并求解得到的线性方程组来计算. P_m:R^2R^2是一个m次的多项式函数,它保证了一定的m次多项式精度。当m1时（即为线性多项式）已经有很好的结果表现，经常比更高次多项式有更好表现. 基函数R的值仅依赖于数据点的距离，因此称为径向。这种插值方法的可微性直接取决于所使用的基函数的可微性R。众所周知，二次径向基函数，最初由R. Hardy提出
R(d)=(d^2+r^2 )^(u/2)		with	 r>0		and		u≠0
Hardy的原始方法不包含多项式P_m。因此，它的多项式精度为0。对于指数u，Hardy建议使用u＝1。u =-1也可以被成功地使用。对于r≠0，基函数是无限可微的。
特征半径r＞0可任意选择。它决定给定数据点内插值的光滑性。对于图像变形，r的选择对良好的结果至关重要。值太小,会导致不良的不均匀变形的图像，值太大，会导致折叠。如果使用固定的r值，甚至上述两种情况有可能在同一张图像中出现。因此，有必要为每个控制点选择r的单独值。
对于每个控制点对应的ri的值,我们可以令其等于控制点pi到最近的其他控制点的距离.
	
r_i=Mⅈn_(i≠j) ⅆ_i (x_j )
这使得当数据点间隔很大时变形较轻微柔和，而当它们靠得更近时变形较剧烈.
	因此,映射函数为:
f(x)=∑_(i=1)^n▒〖_i ((d_i (p))^2+r_i^2 )^(u/2)+x〗
时间复杂度:像所有全局插值方法一样，径向基函数的缺点是，对于每个像素，必须考虑所有控制点。因此，算法的复杂性是O（nN），其中n是控制点的数目,而N为需要变换的像素点的数量。并且 由于求系数_i涉及到解线性方程组，这部分的复杂度为O(n^3)。由于N大多时候远小于n，可以忽略不计，因此总体复杂度为仍是O(nN)。此外，径向基函数有提高计算效率的改进空间.
对于u＝±1的径向基函数，必须计算nN次平方根。即使使用快速平方根近似，也是不可取的。幸运的是，u=-2给出的结果几乎一样好,因此,对于u=-2，平方根的计算被一个除法代替。采用u=-2,可以提高计算效率.

本次程序使用：
f(x)=∑_(i=1)^n▒〖_i ((d_i (p))^2+r_i^2 )^(u/2)+x〗 ,u=-2
## 2.3	白缝问题
解决方法(FillHole函数):程序中记录每个图像内部被映射到的点，然后对于图像内部未被映射到的点(即空洞)则利用周围的已知像素进行插值填充。填充方式是搜索空洞周围3*3矩形区域其余8个点中已被映射到的点,取这些已被映射到的点的颜色的平均值;若周围8个点中没有已被映射到的点,则取周围8个点的颜色的平均值.
